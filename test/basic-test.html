<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
    <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <script src="../../iron-test-helpers/test-helpers.js"></script>
    <link rel="import" href="../../api-view-model-transformer/api-view-model-transformer.html">
    <link rel="import" href="../multipart-payload-editor.html">
  </head>
  <body>
    <api-view-model-transformer></api-view-model-transformer>
    <test-fixture id="basic">
      <template>
        <multipart-payload-editor></multipart-payload-editor>
      </template>
    </test-fixture>

    <script>
    /* global TestHelpers */
    suite('multipart-payload-editor', () => {
      suite('basic', () => {
        let element;

        setup((done) => {
          element = fixture('basic');
          flush(() => done());
        });

        test('model is an array', () => {
          assert.typeOf(element.model, 'array');
        });

        test('model has one item', () => {
          assert.lengthOf(element.model, 1);
        });

        test('added item is a file', () => {
          assert.isTrue(element.model[0].schema.isFile);
        });

        test('value is undefined', () => {
          assert.isUndefined(element.value);
        });

        test('value is messagePreview', () => {
          assert.isUndefined(element.messagePreview);
        });

        test('previewOpened is false', () => {
          assert.isFalse(element.previewOpened);
        });

        test('generatingPreview is undefined', () => {
          assert.isUndefined(element.generatingPreview);
        });
      });

      suite('addFile()', () => {
        let element;

        setup(() => {
          element = fixture('basic');
          element.addFile();
        });

        test('model is an array', () => {
          assert.typeOf(element.model, 'array');
        });

        test('model has two item', () => {
          assert.lengthOf(element.model, 2);
        });

        test('added item is a file', () => {
          assert.isTrue(element.model[1].schema.isFile);
        });

        test('added item has empty name', () => {
          assert.equal(element.model[1].name, '');
        });

        test('added item value is undefined', () => {
          assert.notOk(element.model[1].value);
        });
      });

      suite('addText()', () => {
        let element;

        setup(() => {
          element = fixture('basic');
          element.addText();
        });

        function hasAdvancedSupport() {
          return element.hasFormDataSupport;
        }

        test('model is an array', () => {
          assert.typeOf(element.model, 'array');
        });

        test('model has one item', () => {
          assert.lengthOf(element.model, 2);
        });

        test('added item is not a file', () => {
          assert.isFalse(element.model[1].schema.isFile);
        });

        test('added item has empty name', () => {
          assert.equal(element.model[1].name, '');
        });

        test('added item has empty value', () => {
          assert.equal(element.model[1].value, '');
        });

        test('added item has empty contentType', TestHelpers.skipUnless(hasAdvancedSupport, () => {
          assert.equal(element.model[1].contentType, '');
        }));
      });

      suite('createFormData()', () => {
        let element;

        setup(() => {
          element = fixture('basic');
        });

        test('Do not generate FormData with empty model', () => {
          assert.isUndefined(element.createFormData([]));
        });

        test('Do not generate FormData data for model with empty values', () => {
          assert.isUndefined(element.createFormData([{name: '', schema: {isFile: true}}]));
        });

        test('Generates form data for text value', () => {
          const fd = element.createFormData([{name: 'test', value: 'test', schema: {isFile: false}}]);
          assert.typeOf(fd, 'formdata');
        });

        test('Generates form data for text value with content type', () => {
          const fd = element.createFormData([{
            name: 'test',
            value: 'test',
            schema: {
              isFile: false,
            },
            contentType: 'application/json'
          }]);
          assert.typeOf(fd, 'formdata');
        });

        test('Generates form data for file value', () => {
          const fd = element.createFormData([{
            name: 'test',
            value: new Blob(['test'], {type: 'application/json'}),
            schema: {
              isFile: true
            }
          }]);
          assert.typeOf(fd, 'formdata');
        });
      });

      suite('action controls', () => {
        let element;

        setup(() => {
          element = fixture('basic');
          TestHelpers.forceXIfStamp(element);
        });

        function hasAdvancedSupport() {
          return element.hasFormDataSupport;
        }

        function advancedSupportDisabled() {
          return !element.hasFormDataSupport;
        }

        test('editor-actions are rendered', TestHelpers.skipUnless(hasAdvancedSupport, () => {
          const container = element.$$('.editor-actions');
          assert.ok(container);
        }));

        test('editor-actions are rendered', TestHelpers.skipUnless(advancedSupportDisabled, () => {
          const container = element.$$('.editor-actions');
          assert.notOk(container);
        }));

      });

      suite('_generatePreview()', () => {
        let element;

        setup(() => {
          element = fixture('basic');
        });

        function hasAdvancedSupport() {
          return element.hasFormDataSupport;
        }

        test('Generates preview data for file', TestHelpers.skipUnless(hasAdvancedSupport, () => {
          const fd = element.createFormData([{
            name: 'test',
            value: 'test',
            contentType: 'application/json',
            schema: {isFile: false}
          }]);
          element.value = fd;
          return element._generatePreview()
          .then((content) => {
            assert.typeOf(content, 'strnig');
          });
        }));

        test('Generates preview data for text', TestHelpers.skipUnless(hasAdvancedSupport, () => {
          const fd = element.createFormData([{name: 'test', value: 'test', schema: {isFile: false}}]);
          element.value = fd;
          return element._generatePreview()
          .then((content) => {
            assert.typeOf(content, 'strnig');
          });
        }));

        test('messagePreview is cleared', TestHelpers.skipUnless(hasAdvancedSupport, () => {
          const fd = element.createFormData([{name: 'test', value: 'test', schema: {isFile: false}}]);
          element.value = fd;
          const p = element._generatePreview();
          assert.isUndefined(element.messagePreview);
          return p;
        }));

        test('messagePreview is set after finish',
          TestHelpers.skipUnless(hasAdvancedSupport, () => {
          const fd = element.createFormData([{name: 'test', value: 'test', schema: {isFile: false}}]);
          element.value = fd;
          return element._generatePreview()
          .then(() => {
            assert.typeOf(element.messagePreview, 'strnig');
          });
        }));

        test('generatingPreview is true when working',
          TestHelpers.skipUnless(hasAdvancedSupport, () => {
          const fd = element.createFormData([{name: 'test', value: 'test', schema: {isFile: false}}]);
          element.value = fd;
          element._generatePreview();
          assert.isTrue(element.generatingPreview);
        }));

        test('generatingPreview is false after finish',
          TestHelpers.skipUnless(hasAdvancedSupport, () => {
          const fd = element.createFormData([{name: 'test', value: 'test', schema: {isFile: false}}]);
          element.value = fd;
          return element._generatePreview()
          .then(() => {
            assert.isFalse(element.generatingPreview);
          });
        }));
      });
    });

    suite('Restore form data', () => {
      let fd;
      let element;
      setup(() => {
        fd = new FormData();
        fd.append('text', 'test');
        try {
          fd.append('file', new Blob(['test'], {type: 'plain/text'}));
          fd.append('text-w-ct', new Blob(['test'], {type: 'plain/text'}));
        } catch (e) {}
        element = fixture('basic');
      });

      test('Creates model from FormData', () => {
        if (!element.hasFormDataSupport) {
          return;
        }
        return element._restoreFormData(fd)
        .then(() => {
          assert.typeOf(element.model, 'array');
          assert.lengthOf(element.model, 3);
        });
      });

      test('Restores text data', () => {
        if (!element.hasFormDataSupport) {
          return;
        }
        return element._restoreFormData(fd)
        .then(() => {
          const model = element.model[0];
          assert.isFalse(model.schema.isFile);
          assert.equal(model.name, 'text');
          assert.equal(model.value, 'test');
        });
      });

      test('Restores file data', () => {
        if (!element.hasFormDataSupport) {
          return;
        }
        return element._restoreFormData(fd)
        .then(() => {
          const model = element.model[1];
          assert.isTrue(model.schema.isFile);
          assert.equal(model.name, 'file');
          assert.isTrue(model.value instanceof Blob);
        });
      });

      test('Restores text from ARC meta', () => {
        if (!element.hasFormDataSupport) {
          return;
        }
        fd._arcMeta = {
          textParts: ['text-w-ct']
        };
        return element._restoreFormData(fd)
        .then(() => {
          const model = element.model[2];
          assert.isFalse(model.schema.isFile);
          assert.equal(model.name, 'text-w-ct');
          assert.equal(model.value, 'test');
          assert.equal(model.contentType, 'plain/text');
        });
      });
    });
    </script>

  </body>
</html>
